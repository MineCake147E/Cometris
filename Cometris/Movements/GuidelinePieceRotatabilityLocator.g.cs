// <auto-generated />
// Environment.Version: 8.0.0
using System;
using System.Numerics;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using Cometris.Boards;

namespace Cometris.Movements
{
    public readonly partial struct PieceJLSZRotatabilityLocator<TBitBoard> : IRotatabilityLocator<PieceJLSZRotatabilityLocator<TBitBoard>, TBitBoard>
        where TBitBoard : unmanaged, IBitBoard<TBitBoard, ushort>
    {
        #region RotateFrom
        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromUp(TBitBoard rightMobility, TBitBoard reached)
        {
            // Clockwise rotation from Up to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromUp(TBitBoard leftMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Up to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromRight(TBitBoard downMobility, TBitBoard reached)
        {
            // Clockwise rotation from Right to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromRight(TBitBoard upMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Right to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromDown(TBitBoard leftMobility, TBitBoard reached)
        {
            // Clockwise rotation from Down to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromDown(TBitBoard rightMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Down to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromLeft(TBitBoard upMobility, TBitBoard reached)
        {
            // Clockwise rotation from Left to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromLeft(TBitBoard downMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Left to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        #endregion RotateFrom
        #region RotateTo
        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToUp(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            if (upMobility is PartialBitBoard512 zmm0 && leftReached is PartialBitBoard512 zmm1 && rightReached is PartialBitBoard512 zmm2)
            {
                if (RotateToUpInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToUpInternal(upMobility, leftReached, rightReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToUpInternal(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            // Rotation from Right and Left to Up 
            TBitBoard scc = rightReached;
            TBitBoard scw = leftReached;
            TBitBoard mobility = upMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Left with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & ml1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(ml1, scw);
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            // Test Clockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & mr1d1;
            rtcw0 = scw & ml1d1;
            scc = TBitBoard.AndNot(mr1d1, scc);
            scw = TBitBoard.AndNot(ml1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Right with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Left with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = TBitBoard.AndNot(mu2, scc);
            scw = TBitBoard.AndNot(mu2, scw);
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            rtcc1 = TBitBoard.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            // Test Clockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            rtcc0 = scc & mr1u2;
            rtcw0 = scw & ml1u2;
            scc = TBitBoard.AndNot(mr1u2, scc);
            scw = TBitBoard.AndNot(ml1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToUpInternal(PartialBitBoard512 upMobility, PartialBitBoard512 leftReached, PartialBitBoard512 rightReached)
        {
            // Rotation from Right and Left to Up 
            Vector512<ushort> scc = rightReached;
            Vector512<ushort> scw = leftReached;
            Vector512<ushort> mobility = upMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Left with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & ml1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(ml1, scw);
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            // Test Clockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & mr1d1;
            rtcw0 = scw & ml1d1;
            scc = PartialBitBoard512.AndNot(mr1d1, scc);
            scw = PartialBitBoard512.AndNot(ml1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Right with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Left with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = PartialBitBoard512.AndNot(mu2, scc);
            scw = PartialBitBoard512.AndNot(mu2, scw);
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            rtcc1 = PartialBitBoard512.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            // Test Clockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            rtcc0 = scc & mr1u2;
            rtcw0 = scw & ml1u2;
            scc = PartialBitBoard512.AndNot(mr1u2, scc);
            scw = PartialBitBoard512.AndNot(ml1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToRight(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            if (rightMobility is PartialBitBoard512 zmm0 && upReached is PartialBitBoard512 zmm1 && downReached is PartialBitBoard512 zmm2)
            {
                if (RotateToRightInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToRightInternal(rightMobility, upReached, downReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToRightInternal(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            // Rotation from Down and Up to Right 
            TBitBoard scc = downReached;
            TBitBoard scw = upReached;
            TBitBoard mobility = rightMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Down with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Up with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Test CounterClockwise rotation from Down with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(ml1, scw);
            // Calculate offset #2 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Calculate y = -2 offset #3 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Down with offset #2 (-1, 1)(ml1u1)
            // Test Clockwise rotation from Up with offset #2 (-1, 1)(ml1u1)
            rtcc0 = scc & ml1u1;
            rtcw0 = scw & ml1u1;
            rtcc0 |= rtcw0;
            scc = TBitBoard.AndNot(ml1u1, scc);
            result |= rtcc1;
            scw = TBitBoard.AndNot(ml1u1, scw);
            // Offset #3 (0, -2)(md2) is already available.
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Down with offset #3 (0, -2)(md2)
            // Test Clockwise rotation from Up with offset #3 (0, -2)(md2)
            rtcc0 = TBitBoard.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & md2;
            rtcw1 = scw & md2;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(md2, scc);
            result |= rtcc0;
            scw = TBitBoard.AndNot(md2, scw);
            // Calculate offset #4 (-1, -2) as ml1d2
            var ml1d2 = md2 >> 1;
            rtcc1 = TBitBoard.ShiftDownTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Down with offset #4 (-1, -2)(ml1d2)
            // Test Clockwise rotation from Up with offset #4 (-1, -2)(ml1d2)
            rtcc0 = scc & ml1d2;
            rtcw0 = scw & ml1d2;
            rtcc0 |= rtcw0;
            scc = TBitBoard.AndNot(ml1d2, scc);
            result |= rtcc1;
            scw = TBitBoard.AndNot(ml1d2, scw);
            rtcc0 = rtcc0 << 1;
            rtcc0 = TBitBoard.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToRightInternal(PartialBitBoard512 rightMobility, PartialBitBoard512 upReached, PartialBitBoard512 downReached)
        {
            // Rotation from Down and Up to Right 
            Vector512<ushort> scc = downReached;
            Vector512<ushort> scw = upReached;
            Vector512<ushort> mobility = rightMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Down with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Up with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Test CounterClockwise rotation from Down with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(ml1, scw);
            // Calculate offset #2 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Calculate y = -2 offset #3 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Down with offset #2 (-1, 1)(ml1u1)
            // Test Clockwise rotation from Up with offset #2 (-1, 1)(ml1u1)
            rtcc0 = scc & ml1u1;
            rtcw0 = scw & ml1u1;
            rtcc0 |= rtcw0;
            scc = PartialBitBoard512.AndNot(ml1u1, scc);
            result |= rtcc1;
            scw = PartialBitBoard512.AndNot(ml1u1, scw);
            // Offset #3 (0, -2)(md2) is already available.
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Down with offset #3 (0, -2)(md2)
            // Test Clockwise rotation from Up with offset #3 (0, -2)(md2)
            rtcc0 = PartialBitBoard512.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & md2;
            rtcw1 = scw & md2;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(md2, scc);
            result |= rtcc0;
            scw = PartialBitBoard512.AndNot(md2, scw);
            // Calculate offset #4 (-1, -2) as ml1d2
            var ml1d2 = md2 >> 1;
            rtcc1 = PartialBitBoard512.ShiftDownTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Down with offset #4 (-1, -2)(ml1d2)
            // Test Clockwise rotation from Up with offset #4 (-1, -2)(ml1d2)
            rtcc0 = scc & ml1d2;
            rtcw0 = scw & ml1d2;
            rtcc0 |= rtcw0;
            scc = PartialBitBoard512.AndNot(ml1d2, scc);
            result |= rtcc1;
            scw = PartialBitBoard512.AndNot(ml1d2, scw);
            rtcc0 = rtcc0 << 1;
            rtcc0 = PartialBitBoard512.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToDown(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            if (downMobility is PartialBitBoard512 zmm0 && rightReached is PartialBitBoard512 zmm1 && leftReached is PartialBitBoard512 zmm2)
            {
                if (RotateToDownInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToDownInternal(downMobility, rightReached, leftReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToDownInternal(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            // Rotation from Left and Right to Down 
            TBitBoard scc = leftReached;
            TBitBoard scw = rightReached;
            TBitBoard mobility = downMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Right with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (1, 0)(mr1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & mr1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(mr1, scw);
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & ml1d1;
            rtcw0 = scw & mr1d1;
            scc = TBitBoard.AndNot(ml1d1, scc);
            scw = TBitBoard.AndNot(mr1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Left with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Right with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = TBitBoard.AndNot(mu2, scc);
            scw = TBitBoard.AndNot(mu2, scw);
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            rtcc1 = TBitBoard.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            // Test Clockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            rtcc0 = scc & ml1u2;
            rtcw0 = scw & mr1u2;
            scc = TBitBoard.AndNot(ml1u2, scc);
            scw = TBitBoard.AndNot(mr1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToDownInternal(PartialBitBoard512 downMobility, PartialBitBoard512 rightReached, PartialBitBoard512 leftReached)
        {
            // Rotation from Left and Right to Down 
            Vector512<ushort> scc = leftReached;
            Vector512<ushort> scw = rightReached;
            Vector512<ushort> mobility = downMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Right with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (1, 0)(mr1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & mr1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(mr1, scw);
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & ml1d1;
            rtcw0 = scw & mr1d1;
            scc = PartialBitBoard512.AndNot(ml1d1, scc);
            scw = PartialBitBoard512.AndNot(mr1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Left with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Right with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = PartialBitBoard512.AndNot(mu2, scc);
            scw = PartialBitBoard512.AndNot(mu2, scw);
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            rtcc1 = PartialBitBoard512.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            // Test Clockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            rtcc0 = scc & ml1u2;
            rtcw0 = scw & mr1u2;
            scc = PartialBitBoard512.AndNot(ml1u2, scc);
            scw = PartialBitBoard512.AndNot(mr1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToLeft(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            if (leftMobility is PartialBitBoard512 zmm0 && downReached is PartialBitBoard512 zmm1 && upReached is PartialBitBoard512 zmm2)
            {
                if (RotateToLeftInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToLeftInternal(leftMobility, downReached, upReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToLeftInternal(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            // Rotation from Up and Down to Left 
            TBitBoard scc = upReached;
            TBitBoard scw = downReached;
            TBitBoard mobility = leftMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Up with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Down with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Test CounterClockwise rotation from Up with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(mr1, scw);
            // Calculate offset #2 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            // Calculate y = -2 offset #3 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Up with offset #2 (1, 1)(mr1u1)
            // Test Clockwise rotation from Down with offset #2 (1, 1)(mr1u1)
            rtcc0 = scc & mr1u1;
            rtcw0 = scw & mr1u1;
            rtcc0 |= rtcw0;
            scc = TBitBoard.AndNot(mr1u1, scc);
            result |= rtcc1;
            scw = TBitBoard.AndNot(mr1u1, scw);
            // Offset #3 (0, -2)(md2) is already available.
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Up with offset #3 (0, -2)(md2)
            // Test Clockwise rotation from Down with offset #3 (0, -2)(md2)
            rtcc0 = TBitBoard.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & md2;
            rtcw1 = scw & md2;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(md2, scc);
            result |= rtcc0;
            scw = TBitBoard.AndNot(md2, scw);
            // Calculate offset #4 (1, -2) as mr1d2
            var mr1d2 = md2 << 1;
            rtcc1 = TBitBoard.ShiftDownTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Up with offset #4 (1, -2)(mr1d2)
            // Test Clockwise rotation from Down with offset #4 (1, -2)(mr1d2)
            rtcc0 = scc & mr1d2;
            rtcw0 = scw & mr1d2;
            rtcc0 |= rtcw0;
            scc = TBitBoard.AndNot(mr1d2, scc);
            result |= rtcc1;
            scw = TBitBoard.AndNot(mr1d2, scw);
            rtcc0 = rtcc0 >> 1;
            rtcc0 = TBitBoard.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToLeftInternal(PartialBitBoard512 leftMobility, PartialBitBoard512 downReached, PartialBitBoard512 upReached)
        {
            // Rotation from Up and Down to Left 
            Vector512<ushort> scc = upReached;
            Vector512<ushort> scw = downReached;
            Vector512<ushort> mobility = leftMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Up with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Down with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Test CounterClockwise rotation from Up with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(mr1, scw);
            // Calculate offset #2 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            // Calculate y = -2 offset #3 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Up with offset #2 (1, 1)(mr1u1)
            // Test Clockwise rotation from Down with offset #2 (1, 1)(mr1u1)
            rtcc0 = scc & mr1u1;
            rtcw0 = scw & mr1u1;
            rtcc0 |= rtcw0;
            scc = PartialBitBoard512.AndNot(mr1u1, scc);
            result |= rtcc1;
            scw = PartialBitBoard512.AndNot(mr1u1, scw);
            // Offset #3 (0, -2)(md2) is already available.
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Up with offset #3 (0, -2)(md2)
            // Test Clockwise rotation from Down with offset #3 (0, -2)(md2)
            rtcc0 = PartialBitBoard512.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & md2;
            rtcw1 = scw & md2;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(md2, scc);
            result |= rtcc0;
            scw = PartialBitBoard512.AndNot(md2, scw);
            // Calculate offset #4 (1, -2) as mr1d2
            var mr1d2 = md2 << 1;
            rtcc1 = PartialBitBoard512.ShiftDownTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Up with offset #4 (1, -2)(mr1d2)
            // Test Clockwise rotation from Down with offset #4 (1, -2)(mr1d2)
            rtcc0 = scc & mr1d2;
            rtcw0 = scw & mr1d2;
            rtcc0 |= rtcw0;
            scc = PartialBitBoard512.AndNot(mr1d2, scc);
            result |= rtcc1;
            scw = PartialBitBoard512.AndNot(mr1d2, scw);
            rtcc0 = rtcc0 >> 1;
            rtcc0 = PartialBitBoard512.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        #endregion RotateTo
    }
    public readonly partial struct PieceTRotatabilityLocator<TBitBoard> : IRotatabilityLocator<PieceTRotatabilityLocator<TBitBoard>, TBitBoard>
        where TBitBoard : unmanaged, IBitBoard<TBitBoard, ushort>
    {
        #region RotateFrom
        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromUp(TBitBoard rightMobility, TBitBoard reached)
        {
            // Clockwise rotation from Up to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2) is skipped due to the absence of possible board condition for T piece.
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            // Test for offset #4 (-1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            temp = temp >> 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromUp(TBitBoard leftMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Up to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, -2) is skipped due to the absence of possible board condition for T piece.
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            // Test for offset #4 (1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            temp = temp << 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromRight(TBitBoard downMobility, TBitBoard reached)
        {
            // Clockwise rotation from Right to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromRight(TBitBoard upMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Right to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromDown(TBitBoard leftMobility, TBitBoard reached)
        {
            // Clockwise rotation from Down to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (1, 1) is skipped due to the absence of possible board condition for T piece.
            rtemp = rtemp >> 1;
            result |= rtemp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromDown(TBitBoard rightMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Down to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, 1) is skipped due to the absence of possible board condition for T piece.
            rtemp = rtemp << 1;
            result |= rtemp;
            // Test for offset #3 (0, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromLeft(TBitBoard upMobility, TBitBoard reached)
        {
            // Clockwise rotation from Left to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromLeft(TBitBoard downMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Left to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (0, 0)
            temp = sourceMobility;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (0, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-1, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 1;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        #endregion RotateFrom
        #region RotateTo
        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToUp(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            if (upMobility is PartialBitBoard512 zmm0 && leftReached is PartialBitBoard512 zmm1 && rightReached is PartialBitBoard512 zmm2)
            {
                if (RotateToUpInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToUpInternal(upMobility, leftReached, rightReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToUpInternal(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            // Rotation from Right and Left to Up 
            TBitBoard scc = rightReached;
            TBitBoard scw = leftReached;
            TBitBoard mobility = upMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Left with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & ml1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(ml1, scw);
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            // Test Clockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & mr1d1;
            rtcw0 = scw & ml1d1;
            scc = TBitBoard.AndNot(mr1d1, scc);
            scw = TBitBoard.AndNot(ml1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Right with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Left with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = TBitBoard.AndNot(mu2, scc);
            scw = TBitBoard.AndNot(mu2, scw);
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            rtcc1 = TBitBoard.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            // Test Clockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            rtcc0 = scc & mr1u2;
            rtcw0 = scw & ml1u2;
            scc = TBitBoard.AndNot(mr1u2, scc);
            scw = TBitBoard.AndNot(ml1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToUpInternal(PartialBitBoard512 upMobility, PartialBitBoard512 leftReached, PartialBitBoard512 rightReached)
        {
            // Rotation from Right and Left to Up 
            Vector512<ushort> scc = rightReached;
            Vector512<ushort> scw = leftReached;
            Vector512<ushort> mobility = upMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Left with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & ml1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(ml1, scw);
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            // Test Clockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & mr1d1;
            rtcw0 = scw & ml1d1;
            scc = PartialBitBoard512.AndNot(mr1d1, scc);
            scw = PartialBitBoard512.AndNot(ml1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Right with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Left with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = PartialBitBoard512.AndNot(mu2, scc);
            scw = PartialBitBoard512.AndNot(mu2, scw);
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            rtcc1 = PartialBitBoard512.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            // Test Clockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            rtcc0 = scc & mr1u2;
            rtcw0 = scw & ml1u2;
            scc = PartialBitBoard512.AndNot(mr1u2, scc);
            scw = PartialBitBoard512.AndNot(ml1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 << 1;
            rtcc0 = rtcc0 >> 1;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToRight(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            if (rightMobility is PartialBitBoard512 zmm0 && upReached is PartialBitBoard512 zmm1 && downReached is PartialBitBoard512 zmm2)
            {
                if (RotateToRightInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToRightInternal(rightMobility, upReached, downReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToRightInternal(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            // Rotation from Down and Up to Right 
            TBitBoard scc = downReached;
            TBitBoard scw = upReached;
            TBitBoard mobility = rightMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Down with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Up with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Calculate y = -2 offset #2 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            // Test CounterClockwise rotation from Down with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(ml1, scw);
            // Calculate offset #2 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Offset #2 (0, -2)(md2) is already available.
            rtcc1 = rtcc1 << 1;
            // Test Clockwise rotation from Up with offset #2 (-1, 1)(ml1u1)
            // Test CounterClockwise rotation from Down with offset #2 (0, -2)(md2)
            rtcw0 = scw & ml1u1;
            rtcc0 = scc & md2;
            scw = TBitBoard.AndNot(ml1u1, scw);
            scc = TBitBoard.AndNot(md2, scc);
            result |= rtcc1;
            // Calculate offset #3 (-1, -2) as ml1d2
            var ml1d2 = md2 >> 1;
            rtcc0 = TBitBoard.ShiftDownTwoLines(rtcc0, filled);
            rtcw0 = rtcw0 << 1;
            // Test CounterClockwise rotation from Down with offset #3 (-1, -2)(ml1d2)
            // Test Clockwise rotation from Up with offset #3 (-1, -2)(ml1d2)
            rtcw0 = TBitBoard.ShiftUpOneLine(rtcw0, filled);
            rtcc1 = scc & ml1d2;
            rtcw1 = scw & ml1d2;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(ml1d2, scc);
            scw = TBitBoard.AndNot(ml1d2, scw);
            result = TBitBoard.OrAll(result, rtcw0, rtcc0);
            rtcc1 = rtcc1 << 1;
            rtcc1 = TBitBoard.ShiftDownTwoLines(rtcc1, filled);
            result |= rtcc1;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToRightInternal(PartialBitBoard512 rightMobility, PartialBitBoard512 upReached, PartialBitBoard512 downReached)
        {
            // Rotation from Down and Up to Right 
            Vector512<ushort> scc = downReached;
            Vector512<ushort> scw = upReached;
            Vector512<ushort> mobility = rightMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Down with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Up with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Calculate y = -2 offset #2 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            // Test CounterClockwise rotation from Down with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(ml1, scw);
            // Calculate offset #2 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Offset #2 (0, -2)(md2) is already available.
            rtcc1 = rtcc1 << 1;
            // Test Clockwise rotation from Up with offset #2 (-1, 1)(ml1u1)
            // Test CounterClockwise rotation from Down with offset #2 (0, -2)(md2)
            rtcw0 = scw & ml1u1;
            rtcc0 = scc & md2;
            scw = PartialBitBoard512.AndNot(ml1u1, scw);
            scc = PartialBitBoard512.AndNot(md2, scc);
            result |= rtcc1;
            // Calculate offset #3 (-1, -2) as ml1d2
            var ml1d2 = md2 >> 1;
            rtcc0 = PartialBitBoard512.ShiftDownTwoLines(rtcc0, filled);
            rtcw0 = rtcw0 << 1;
            // Test CounterClockwise rotation from Down with offset #3 (-1, -2)(ml1d2)
            // Test Clockwise rotation from Up with offset #3 (-1, -2)(ml1d2)
            rtcw0 = PartialBitBoard512.ShiftUpOneLine(rtcw0, filled);
            rtcc1 = scc & ml1d2;
            rtcw1 = scw & ml1d2;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(ml1d2, scc);
            scw = PartialBitBoard512.AndNot(ml1d2, scw);
            result = PartialBitBoard512.OrAll(result, rtcw0, rtcc0);
            rtcc1 = rtcc1 << 1;
            rtcc1 = PartialBitBoard512.ShiftDownTwoLines(rtcc1, filled);
            result |= rtcc1;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToDown(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            if (downMobility is PartialBitBoard512 zmm0 && rightReached is PartialBitBoard512 zmm1 && leftReached is PartialBitBoard512 zmm2)
            {
                if (RotateToDownInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToDownInternal(downMobility, rightReached, leftReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToDownInternal(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            // Rotation from Left and Right to Down 
            TBitBoard scc = leftReached;
            TBitBoard scw = rightReached;
            TBitBoard mobility = downMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Right with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (1, 0)(mr1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & mr1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(mr1, scw);
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & ml1d1;
            rtcw0 = scw & mr1d1;
            scc = TBitBoard.AndNot(ml1d1, scc);
            scw = TBitBoard.AndNot(mr1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Left with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Right with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = TBitBoard.AndNot(mu2, scc);
            scw = TBitBoard.AndNot(mu2, scw);
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            rtcc1 = TBitBoard.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            // Test Clockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            rtcc0 = scc & ml1u2;
            rtcw0 = scw & mr1u2;
            scc = TBitBoard.AndNot(ml1u2, scc);
            scw = TBitBoard.AndNot(mr1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToDownInternal(PartialBitBoard512 downMobility, PartialBitBoard512 rightReached, PartialBitBoard512 leftReached)
        {
            // Rotation from Left and Right to Down 
            Vector512<ushort> scc = leftReached;
            Vector512<ushort> scw = rightReached;
            Vector512<ushort> mobility = downMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Right with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = -1 offset #2 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (1, 0)(mr1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & mr1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(mr1, scw);
            // Calculate offset #2 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            // Calculate offset #2 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = 2 offset #3 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #2 (1, -1)(mr1d1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = scc & ml1d1;
            rtcw0 = scw & mr1d1;
            scc = PartialBitBoard512.AndNot(ml1d1, scc);
            scw = PartialBitBoard512.AndNot(mr1d1, scw);
            // Offset #3 (0, 2)(mu2) is already available.
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Left with offset #3 (0, 2)(mu2)
            // Test Clockwise rotation from Right with offset #3 (0, 2)(mu2)
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & mu2;
            rtcw1 = scw & mu2;
            rtcc1 |= rtcw1;
            result |= rtcc0;
            scc = PartialBitBoard512.AndNot(mu2, scc);
            scw = PartialBitBoard512.AndNot(mu2, scw);
            // Calculate offset #4 (-1, 2) as ml1u2
            var ml1u2 = mu2 >> 1;
            // Calculate offset #4 (1, 2) as mr1u2
            var mr1u2 = mu2 << 1;
            rtcc1 = PartialBitBoard512.ShiftUpTwoLines(rtcc1, filled);
            // Test CounterClockwise rotation from Left with offset #4 (-1, 2)(ml1u2)
            // Test Clockwise rotation from Right with offset #4 (1, 2)(mr1u2)
            rtcc0 = scc & ml1u2;
            rtcw0 = scw & mr1u2;
            scc = PartialBitBoard512.AndNot(ml1u2, scc);
            scw = PartialBitBoard512.AndNot(mr1u2, scw);
            result |= rtcc1;
            rtcw0 = rtcw0 >> 1;
            rtcc0 = rtcc0 << 1;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToLeft(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            if (leftMobility is PartialBitBoard512 zmm0 && downReached is PartialBitBoard512 zmm1 && upReached is PartialBitBoard512 zmm2)
            {
                if (RotateToLeftInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToLeftInternal(leftMobility, downReached, upReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToLeftInternal(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            // Rotation from Up and Down to Left 
            TBitBoard scc = upReached;
            TBitBoard scw = downReached;
            TBitBoard mobility = leftMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Up with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Down with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = TBitBoard.AndNot(m, scc);
            scw = TBitBoard.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Calculate y = -2 offset #2 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            // Test CounterClockwise rotation from Up with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(mr1, scw);
            // Calculate offset #2 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            // Offset #2 (0, -2)(md2) is already available.
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Up with offset #2 (1, 1)(mr1u1)
            // Test Clockwise rotation from Down with offset #2 (0, -2)(md2)
            rtcc0 = scc & mr1u1;
            rtcw0 = scw & md2;
            scc = TBitBoard.AndNot(mr1u1, scc);
            scw = TBitBoard.AndNot(md2, scw);
            result |= rtcc1;
            // Calculate offset #3 (1, -2) as mr1d2
            var mr1d2 = md2 << 1;
            rtcw0 = TBitBoard.ShiftDownTwoLines(rtcw0, filled);
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Up with offset #3 (1, -2)(mr1d2)
            // Test Clockwise rotation from Down with offset #3 (1, -2)(mr1d2)
            rtcc0 = TBitBoard.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & mr1d2;
            rtcw1 = scw & mr1d2;
            rtcc1 |= rtcw1;
            scc = TBitBoard.AndNot(mr1d2, scc);
            scw = TBitBoard.AndNot(mr1d2, scw);
            result = TBitBoard.OrAll(result, rtcc0, rtcw0);
            rtcc1 = rtcc1 >> 1;
            rtcc1 = TBitBoard.ShiftDownTwoLines(rtcc1, filled);
            result |= rtcc1;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToLeftInternal(PartialBitBoard512 leftMobility, PartialBitBoard512 downReached, PartialBitBoard512 upReached)
        {
            // Rotation from Up and Down to Left 
            Vector512<ushort> scc = upReached;
            Vector512<ushort> scw = downReached;
            Vector512<ushort> mobility = leftMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Offset #0 (0, 0)(m) is already available.
            // Test CounterClockwise rotation from Up with offset #0 (0, 0)(m)
            // Test Clockwise rotation from Down with offset #0 (0, 0)(m)
            rtcc0 = scc & m;
            rtcw0 = scw & m;
            scc = PartialBitBoard512.AndNot(m, scc);
            scw = PartialBitBoard512.AndNot(m, scw);
            result = rtcc0 | rtcw0;
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate y = 1 offset #2 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Calculate y = -2 offset #2 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            // Test CounterClockwise rotation from Up with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(mr1, scw);
            // Calculate offset #2 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            // Offset #2 (0, -2)(md2) is already available.
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Up with offset #2 (1, 1)(mr1u1)
            // Test Clockwise rotation from Down with offset #2 (0, -2)(md2)
            rtcc0 = scc & mr1u1;
            rtcw0 = scw & md2;
            scc = PartialBitBoard512.AndNot(mr1u1, scc);
            scw = PartialBitBoard512.AndNot(md2, scw);
            result |= rtcc1;
            // Calculate offset #3 (1, -2) as mr1d2
            var mr1d2 = md2 << 1;
            rtcw0 = PartialBitBoard512.ShiftDownTwoLines(rtcw0, filled);
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Up with offset #3 (1, -2)(mr1d2)
            // Test Clockwise rotation from Down with offset #3 (1, -2)(mr1d2)
            rtcc0 = PartialBitBoard512.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & mr1d2;
            rtcw1 = scw & mr1d2;
            rtcc1 |= rtcw1;
            scc = PartialBitBoard512.AndNot(mr1d2, scc);
            scw = PartialBitBoard512.AndNot(mr1d2, scw);
            result = PartialBitBoard512.OrAll(result, rtcc0, rtcw0);
            rtcc1 = rtcc1 >> 1;
            rtcc1 = PartialBitBoard512.ShiftDownTwoLines(rtcc1, filled);
            result |= rtcc1;
            return result;
        }

        #endregion RotateTo
    }
    public readonly partial struct PieceIRotatabilityLocator<TBitBoard> : IRotatabilityLocator<PieceIRotatabilityLocator<TBitBoard>, TBitBoard>
        where TBitBoard : unmanaged, IBitBoard<TBitBoard, ushort>
    {
        #region RotateFrom
        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromUp(TBitBoard rightMobility, TBitBoard reached)
        {
            // Clockwise rotation from Up to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            rtemp = rtemp >> 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (2, 0)
            temp = sourceMobility;
            rtemp = rtemp << 1;
            temp = temp << 2;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 2;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (2, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 2;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromUp(TBitBoard leftMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Up to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (0, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (2, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (-1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 2;
            temp = temp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (2, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 2;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromRight(TBitBoard downMobility, TBitBoard reached)
        {
            // Clockwise rotation from Right to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (0, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (2, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (-1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 2;
            temp = temp >> 1;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (2, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 2;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromRight(TBitBoard upMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Right to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            rtemp = rtemp << 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-2, 0)
            temp = sourceMobility;
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp << 2;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-2, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 2;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromDown(TBitBoard leftMobility, TBitBoard reached)
        {
            // Clockwise rotation from Down to Left 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = leftMobility;
            // Test for offset #0 (-1, 0)
            temp = sourceMobility;
            temp = temp >> 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 0)
            temp = sourceMobility;
            rtemp = rtemp << 1;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-2, 0)
            temp = sourceMobility;
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp << 2;
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-2, -2)
            temp = TBitBoard.ShiftUpTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 2;
            rtemp = TBitBoard.ShiftDownTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromDown(TBitBoard rightMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Down to Right 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = rightMobility;
            // Test for offset #0 (0, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-2, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 2;
            temp = temp << 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-2, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 2;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateClockwiseFromLeft(TBitBoard upMobility, TBitBoard reached)
        {
            // Clockwise rotation from Left to Up 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = upMobility;
            // Test for offset #0 (0, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (1, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            temp = temp << 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (-2, 1)
            temp = TBitBoard.ShiftDownOneLine(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp << 2;
            temp = temp << 1;
            rtemp = TBitBoard.ShiftUpOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (-2, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp >> 1;
            temp = temp >> 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp << 2;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateCounterClockwiseFromLeft(TBitBoard downMobility, TBitBoard reached)
        {
            // CounterClockwise rotation from Left to Down 
            TBitBoard startPoints = reached;
            TBitBoard result = default;
            TBitBoard temp = default;
            TBitBoard rtemp = default;
            TBitBoard sourceMobility = downMobility;
            // Test for offset #0 (1, 0)
            temp = sourceMobility;
            temp = temp << 1;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #1 (-1, 0)
            temp = sourceMobility;
            rtemp = rtemp >> 1;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #2 (2, 0)
            temp = sourceMobility;
            rtemp = rtemp << 1;
            temp = temp << 2;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #3 (-1, -1)
            temp = TBitBoard.ShiftUpOneLine(sourceMobility, 0);
            rtemp = rtemp >> 2;
            temp = temp >> 1;
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            // Test for offset #4 (2, 2)
            temp = TBitBoard.ShiftDownTwoLines(sourceMobility, 0);
            rtemp = rtemp << 1;
            temp = temp << 2;
            rtemp = TBitBoard.ShiftDownOneLine(rtemp, 0);
            result |= rtemp;
            rtemp = temp & startPoints;
            startPoints &= ~temp;
            rtemp = rtemp >> 2;
            rtemp = TBitBoard.ShiftUpTwoLines(rtemp, 0);
            result |= rtemp;
            return result;
        }

        #endregion RotateFrom
        #region RotateTo
        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToUp(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            if (upMobility is PartialBitBoard512 zmm0 && leftReached is PartialBitBoard512 zmm1 && rightReached is PartialBitBoard512 zmm2)
            {
                if (RotateToUpInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToUpInternal(upMobility, leftReached, rightReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToUpInternal(TBitBoard upMobility, TBitBoard leftReached, TBitBoard rightReached)
        {
            // Rotation from Right and Left to Up 
            TBitBoard scc = rightReached;
            TBitBoard scw = leftReached;
            TBitBoard mobility = upMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = 1 offset #0 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Calculate offset #0 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Offset #0 (0, 1)(mu1) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (-1, 0)(ml1)
            // Test Clockwise rotation from Left with offset #0 (0, 1)(mu1)
            rtcc0 = scc & ml1;
            rtcw0 = scw & mu1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(mu1, scw);
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcw0 = TBitBoard.ShiftUpOneLine(rtcw0, filled);
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (1, 1)(mr1u1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1u1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(mr1u1, scw);
            // Calculate offset #2 (-2, 0) as ml2
            var ml2 = m >> 2;
            // Calculate offset #2 (-2, 1) as ml2u1
            var ml2u1 = mu1 >> 2;
            result = rtcc0 | rtcw0;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = -1 offset #3 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (-2, 0)(ml2)
            // Test Clockwise rotation from Left with offset #2 (-2, 1)(ml2u1)
            rtcw1 = TBitBoard.ShiftUpOneLine(rtcw1, filled);
            rtcc0 = scc & ml2;
            rtcw0 = scw & ml2u1;
            scc = TBitBoard.AndNot(ml2, scc);
            scw = TBitBoard.AndNot(ml2u1, scw);
            // Calculate offset #3 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw0 = rtcw0 << 2;
            // Calculate y = -2 offset #4 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            // Calculate y = 2 offset #4 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcc0 = rtcc0 << 2;
            // Test CounterClockwise rotation from Right with offset #3 (1, 1)(mr1u1)
            // Test Clockwise rotation from Left with offset #3 (1, -1)(mr1d1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcw0 = TBitBoard.ShiftUpOneLine(rtcw0, filled);
            rtcw1 = scw & mr1d1;
            rtcc1 = scc & mr1u1;
            scw = TBitBoard.AndNot(mr1d1, scw);
            scc = TBitBoard.AndNot(mr1u1, scc);
            // Calculate offset #4 (-2, -2) as ml2d2
            var ml2d2 = md2 >> 2;
            // Calculate offset #4 (-2, 2) as ml2u2
            var ml2u2 = mu2 >> 2;
            rtcw1 = rtcw1 >> 1;
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #4 (-2, -2)(ml2d2)
            // Test Clockwise rotation from Left with offset #4 (-2, 2)(ml2u2)
            result = TBitBoard.OrAll(result, rtcc0, rtcw0);
            rtcw1 = TBitBoard.ShiftDownOneLine(rtcw1, filled);
            rtcc0 = scc & ml2d2;
            rtcw0 = scw & ml2u2;
            rtcc1 = TBitBoard.ShiftUpOneLine(rtcc1, filled);
            scc = TBitBoard.AndNot(ml2d2, scc);
            scw = TBitBoard.AndNot(ml2u2, scw);
            rtcw0 = rtcw0 << 2;
            rtcc0 = rtcc0 << 2;
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = TBitBoard.ShiftDownTwoLines(rtcc0, filled);
            rtcw0 = TBitBoard.ShiftUpTwoLines(rtcw0, filled);
            result = TBitBoard.OrAll(result, rtcc0, rtcw0);
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToUpInternal(PartialBitBoard512 upMobility, PartialBitBoard512 leftReached, PartialBitBoard512 rightReached)
        {
            // Rotation from Right and Left to Up 
            Vector512<ushort> scc = rightReached;
            Vector512<ushort> scw = leftReached;
            Vector512<ushort> mobility = upMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = 1 offset #0 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Calculate offset #0 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Offset #0 (0, 1)(mu1) is already available.
            // Test CounterClockwise rotation from Right with offset #0 (-1, 0)(ml1)
            // Test Clockwise rotation from Left with offset #0 (0, 1)(mu1)
            rtcc0 = scc & ml1;
            rtcw0 = scw & mu1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(mu1, scw);
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcw0 = PartialBitBoard512.ShiftUpOneLine(rtcw0, filled);
            rtcc0 = rtcc0 << 1;
            // Test CounterClockwise rotation from Right with offset #1 (1, 0)(mr1)
            // Test Clockwise rotation from Left with offset #1 (1, 1)(mr1u1)
            rtcc1 = scc & mr1;
            rtcw1 = scw & mr1u1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(mr1u1, scw);
            // Calculate offset #2 (-2, 0) as ml2
            var ml2 = m >> 2;
            // Calculate offset #2 (-2, 1) as ml2u1
            var ml2u1 = mu1 >> 2;
            result = rtcc0 | rtcw0;
            rtcw1 = rtcw1 >> 1;
            // Calculate y = -1 offset #3 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #2 (-2, 0)(ml2)
            // Test Clockwise rotation from Left with offset #2 (-2, 1)(ml2u1)
            rtcw1 = PartialBitBoard512.ShiftUpOneLine(rtcw1, filled);
            rtcc0 = scc & ml2;
            rtcw0 = scw & ml2u1;
            scc = PartialBitBoard512.AndNot(ml2, scc);
            scw = PartialBitBoard512.AndNot(ml2u1, scw);
            // Calculate offset #3 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            rtcw0 = rtcw0 << 2;
            // Calculate y = -2 offset #4 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            // Calculate y = 2 offset #4 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcc0 = rtcc0 << 2;
            // Test CounterClockwise rotation from Right with offset #3 (1, 1)(mr1u1)
            // Test Clockwise rotation from Left with offset #3 (1, -1)(mr1d1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcw0 = PartialBitBoard512.ShiftUpOneLine(rtcw0, filled);
            rtcw1 = scw & mr1d1;
            rtcc1 = scc & mr1u1;
            scw = PartialBitBoard512.AndNot(mr1d1, scw);
            scc = PartialBitBoard512.AndNot(mr1u1, scc);
            // Calculate offset #4 (-2, -2) as ml2d2
            var ml2d2 = md2 >> 2;
            // Calculate offset #4 (-2, 2) as ml2u2
            var ml2u2 = mu2 >> 2;
            rtcw1 = rtcw1 >> 1;
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Right with offset #4 (-2, -2)(ml2d2)
            // Test Clockwise rotation from Left with offset #4 (-2, 2)(ml2u2)
            result = PartialBitBoard512.OrAll(result, rtcc0, rtcw0);
            rtcw1 = PartialBitBoard512.ShiftDownOneLine(rtcw1, filled);
            rtcc0 = scc & ml2d2;
            rtcw0 = scw & ml2u2;
            rtcc1 = PartialBitBoard512.ShiftUpOneLine(rtcc1, filled);
            scc = PartialBitBoard512.AndNot(ml2d2, scc);
            scw = PartialBitBoard512.AndNot(ml2u2, scw);
            rtcw0 = rtcw0 << 2;
            rtcc0 = rtcc0 << 2;
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = PartialBitBoard512.ShiftDownTwoLines(rtcc0, filled);
            rtcw0 = PartialBitBoard512.ShiftUpTwoLines(rtcw0, filled);
            result = PartialBitBoard512.OrAll(result, rtcc0, rtcw0);
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToRight(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            if (rightMobility is PartialBitBoard512 zmm0 && upReached is PartialBitBoard512 zmm1 && downReached is PartialBitBoard512 zmm2)
            {
                if (RotateToRightInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToRightInternal(rightMobility, upReached, downReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToRightInternal(TBitBoard rightMobility, TBitBoard upReached, TBitBoard downReached)
        {
            // Rotation from Down and Up to Right 
            TBitBoard scc = downReached;
            TBitBoard scw = upReached;
            TBitBoard mobility = rightMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = 1 offset #0 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            // Calculate offset #0 (1, 0) as mr1
            var mr1 = m << 1;
            // Offset #0 (0, 1)(mu1) is already available.
            // Test Clockwise rotation from Up with offset #0 (1, 0)(mr1)
            // Test CounterClockwise rotation from Down with offset #0 (0, 1)(mu1)
            rtcw0 = scw & mr1;
            rtcc0 = scc & mu1;
            scw = TBitBoard.AndNot(mr1, scw);
            scc = TBitBoard.AndNot(mu1, scc);
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcc0 = TBitBoard.ShiftUpOneLine(rtcc0, filled);
            rtcw0 = rtcw0 >> 1;
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            // Test CounterClockwise rotation from Down with offset #1 (1, 1)(mr1u1)
            rtcw1 = scw & ml1;
            rtcc1 = scc & mr1u1;
            scw = TBitBoard.AndNot(ml1, scw);
            scc = TBitBoard.AndNot(mr1u1, scc);
            // Calculate offset #2 (2, 0) as mr2
            var mr2 = m << 2;
            // Calculate offset #2 (-2, 1) as ml2u1
            var ml2u1 = mu1 >> 2;
            result = rtcw0 | rtcc0;
            rtcc1 = rtcc1 >> 1;
            // Calculate y = -1 offset #3 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            rtcw1 = rtcw1 << 1;
            // Test Clockwise rotation from Up with offset #2 (2, 0)(mr2)
            // Test CounterClockwise rotation from Down with offset #2 (-2, 1)(ml2u1)
            rtcc1 = TBitBoard.ShiftUpOneLine(rtcc1, filled);
            rtcw0 = scw & mr2;
            rtcc0 = scc & ml2u1;
            scw = TBitBoard.AndNot(mr2, scw);
            scc = TBitBoard.AndNot(ml2u1, scc);
            // Calculate offset #3 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #3 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcc0 = rtcc0 << 2;
            // Calculate y = 2 offset #4 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            rtcw0 = rtcw0 >> 2;
            // Test CounterClockwise rotation from Down with offset #3 (1, -1)(mr1d1)
            // Test Clockwise rotation from Up with offset #3 (-1, -1)(ml1d1)
            result = TBitBoard.OrAll(result, rtcw1, rtcc1);
            rtcc0 = TBitBoard.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & mr1d1;
            rtcw1 = scw & ml1d1;
            scc = TBitBoard.AndNot(mr1d1, scc);
            scw = TBitBoard.AndNot(ml1d1, scw);
            // Calculate offset #4 (-2, 2) as ml2u2
            var ml2u2 = mu2 >> 2;
            // Calculate offset #4 (2, 2) as mr2u2
            var mr2u2 = mu2 << 2;
            rtcw1 = rtcw1 << 1;
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Down with offset #4 (-2, 2)(ml2u2)
            // Test Clockwise rotation from Up with offset #4 (2, 2)(mr2u2)
            rtcc1 |= rtcw1;
            result = TBitBoard.OrAll(result, rtcw0, rtcc0);
            rtcc1 = TBitBoard.ShiftDownOneLine(rtcc1, filled);
            rtcc0 = scc & ml2u2;
            rtcw0 = scw & mr2u2;
            result |= rtcc1;
            scc = TBitBoard.AndNot(ml2u2, scc);
            scw = TBitBoard.AndNot(mr2u2, scw);
            rtcw0 = rtcw0 >> 2;
            rtcc0 = rtcc0 << 2;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToRightInternal(PartialBitBoard512 rightMobility, PartialBitBoard512 upReached, PartialBitBoard512 downReached)
        {
            // Rotation from Down and Up to Right 
            Vector512<ushort> scc = downReached;
            Vector512<ushort> scw = upReached;
            Vector512<ushort> mobility = rightMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = 1 offset #0 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            // Calculate offset #0 (1, 0) as mr1
            var mr1 = m << 1;
            // Offset #0 (0, 1)(mu1) is already available.
            // Test Clockwise rotation from Up with offset #0 (1, 0)(mr1)
            // Test CounterClockwise rotation from Down with offset #0 (0, 1)(mu1)
            rtcw0 = scw & mr1;
            rtcc0 = scc & mu1;
            scw = PartialBitBoard512.AndNot(mr1, scw);
            scc = PartialBitBoard512.AndNot(mu1, scc);
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcc0 = PartialBitBoard512.ShiftUpOneLine(rtcc0, filled);
            rtcw0 = rtcw0 >> 1;
            // Test Clockwise rotation from Up with offset #1 (-1, 0)(ml1)
            // Test CounterClockwise rotation from Down with offset #1 (1, 1)(mr1u1)
            rtcw1 = scw & ml1;
            rtcc1 = scc & mr1u1;
            scw = PartialBitBoard512.AndNot(ml1, scw);
            scc = PartialBitBoard512.AndNot(mr1u1, scc);
            // Calculate offset #2 (2, 0) as mr2
            var mr2 = m << 2;
            // Calculate offset #2 (-2, 1) as ml2u1
            var ml2u1 = mu1 >> 2;
            result = rtcw0 | rtcc0;
            rtcc1 = rtcc1 >> 1;
            // Calculate y = -1 offset #3 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            rtcw1 = rtcw1 << 1;
            // Test Clockwise rotation from Up with offset #2 (2, 0)(mr2)
            // Test CounterClockwise rotation from Down with offset #2 (-2, 1)(ml2u1)
            rtcc1 = PartialBitBoard512.ShiftUpOneLine(rtcc1, filled);
            rtcw0 = scw & mr2;
            rtcc0 = scc & ml2u1;
            scw = PartialBitBoard512.AndNot(mr2, scw);
            scc = PartialBitBoard512.AndNot(ml2u1, scc);
            // Calculate offset #3 (1, -1) as mr1d1
            var mr1d1 = md1 << 1;
            // Calculate offset #3 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcc0 = rtcc0 << 2;
            // Calculate y = 2 offset #4 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            rtcw0 = rtcw0 >> 2;
            // Test CounterClockwise rotation from Down with offset #3 (1, -1)(mr1d1)
            // Test Clockwise rotation from Up with offset #3 (-1, -1)(ml1d1)
            result = PartialBitBoard512.OrAll(result, rtcw1, rtcc1);
            rtcc0 = PartialBitBoard512.ShiftUpOneLine(rtcc0, filled);
            rtcc1 = scc & mr1d1;
            rtcw1 = scw & ml1d1;
            scc = PartialBitBoard512.AndNot(mr1d1, scc);
            scw = PartialBitBoard512.AndNot(ml1d1, scw);
            // Calculate offset #4 (-2, 2) as ml2u2
            var ml2u2 = mu2 >> 2;
            // Calculate offset #4 (2, 2) as mr2u2
            var mr2u2 = mu2 << 2;
            rtcw1 = rtcw1 << 1;
            rtcc1 = rtcc1 >> 1;
            // Test CounterClockwise rotation from Down with offset #4 (-2, 2)(ml2u2)
            // Test Clockwise rotation from Up with offset #4 (2, 2)(mr2u2)
            rtcc1 |= rtcw1;
            result = PartialBitBoard512.OrAll(result, rtcw0, rtcc0);
            rtcc1 = PartialBitBoard512.ShiftDownOneLine(rtcc1, filled);
            rtcc0 = scc & ml2u2;
            rtcw0 = scw & mr2u2;
            result |= rtcc1;
            scc = PartialBitBoard512.AndNot(ml2u2, scc);
            scw = PartialBitBoard512.AndNot(mr2u2, scw);
            rtcw0 = rtcw0 >> 2;
            rtcc0 = rtcc0 << 2;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToDown(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            if (downMobility is PartialBitBoard512 zmm0 && rightReached is PartialBitBoard512 zmm1 && leftReached is PartialBitBoard512 zmm2)
            {
                if (RotateToDownInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToDownInternal(downMobility, rightReached, leftReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToDownInternal(TBitBoard downMobility, TBitBoard rightReached, TBitBoard leftReached)
        {
            // Rotation from Left and Right to Down 
            TBitBoard scc = leftReached;
            TBitBoard scw = rightReached;
            TBitBoard mobility = downMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = -1 offset #0 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Calculate offset #0 (1, 0) as mr1
            var mr1 = m << 1;
            // Offset #0 (0, -1)(md1) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (1, 0)(mr1)
            // Test Clockwise rotation from Right with offset #0 (0, -1)(md1)
            rtcc0 = scc & mr1;
            rtcw0 = scw & md1;
            scc = TBitBoard.AndNot(mr1, scc);
            scw = TBitBoard.AndNot(md1, scw);
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw0 = TBitBoard.ShiftDownOneLine(rtcw0, filled);
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (-1, -1)(ml1d1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1d1;
            scc = TBitBoard.AndNot(ml1, scc);
            scw = TBitBoard.AndNot(ml1d1, scw);
            // Calculate offset #2 (2, 0) as mr2
            var mr2 = m << 2;
            // Calculate offset #2 (2, -1) as mr2d1
            var mr2d1 = md1 << 2;
            result = rtcc0 | rtcw0;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 1 offset #3 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (2, 0)(mr2)
            // Test Clockwise rotation from Right with offset #2 (2, -1)(mr2d1)
            rtcw1 = TBitBoard.ShiftDownOneLine(rtcw1, filled);
            rtcc0 = scc & mr2;
            rtcw0 = scw & mr2d1;
            scc = TBitBoard.AndNot(mr2, scc);
            scw = TBitBoard.AndNot(mr2d1, scw);
            // Calculate offset #3 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            rtcw0 = rtcw0 >> 2;
            // Calculate y = 2 offset #4 as mu2
            var mu2 = TBitBoard.ShiftDownTwoLines(mobility, filled);
            // Calculate y = -2 offset #4 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            rtcc0 = rtcc0 >> 2;
            // Test CounterClockwise rotation from Left with offset #3 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #3 (-1, 1)(ml1u1)
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcw0 = TBitBoard.ShiftDownOneLine(rtcw0, filled);
            rtcw1 = scw & ml1u1;
            rtcc1 = scc & ml1d1;
            scw = TBitBoard.AndNot(ml1u1, scw);
            scc = TBitBoard.AndNot(ml1d1, scc);
            // Calculate offset #4 (2, 2) as mr2u2
            var mr2u2 = mu2 << 2;
            // Calculate offset #4 (2, -2) as mr2d2
            var mr2d2 = md2 << 2;
            rtcw1 = rtcw1 << 1;
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #4 (2, 2)(mr2u2)
            // Test Clockwise rotation from Right with offset #4 (2, -2)(mr2d2)
            result = TBitBoard.OrAll(result, rtcc0, rtcw0);
            rtcw1 = TBitBoard.ShiftUpOneLine(rtcw1, filled);
            rtcc0 = scc & mr2u2;
            rtcw0 = scw & mr2d2;
            rtcc1 = TBitBoard.ShiftDownOneLine(rtcc1, filled);
            scc = TBitBoard.AndNot(mr2u2, scc);
            scw = TBitBoard.AndNot(mr2d2, scw);
            rtcw0 = rtcw0 >> 2;
            rtcc0 = rtcc0 >> 2;
            result = TBitBoard.OrAll(result, rtcc1, rtcw1);
            rtcc0 = TBitBoard.ShiftUpTwoLines(rtcc0, filled);
            rtcw0 = TBitBoard.ShiftDownTwoLines(rtcw0, filled);
            result = TBitBoard.OrAll(result, rtcc0, rtcw0);
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToDownInternal(PartialBitBoard512 downMobility, PartialBitBoard512 rightReached, PartialBitBoard512 leftReached)
        {
            // Rotation from Left and Right to Down 
            Vector512<ushort> scc = leftReached;
            Vector512<ushort> scw = rightReached;
            Vector512<ushort> mobility = downMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = -1 offset #0 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Calculate offset #0 (1, 0) as mr1
            var mr1 = m << 1;
            // Offset #0 (0, -1)(md1) is already available.
            // Test CounterClockwise rotation from Left with offset #0 (1, 0)(mr1)
            // Test Clockwise rotation from Right with offset #0 (0, -1)(md1)
            rtcc0 = scc & mr1;
            rtcw0 = scw & md1;
            scc = PartialBitBoard512.AndNot(mr1, scc);
            scw = PartialBitBoard512.AndNot(md1, scw);
            // Calculate offset #1 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Calculate offset #1 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcw0 = PartialBitBoard512.ShiftDownOneLine(rtcw0, filled);
            rtcc0 = rtcc0 >> 1;
            // Test CounterClockwise rotation from Left with offset #1 (-1, 0)(ml1)
            // Test Clockwise rotation from Right with offset #1 (-1, -1)(ml1d1)
            rtcc1 = scc & ml1;
            rtcw1 = scw & ml1d1;
            scc = PartialBitBoard512.AndNot(ml1, scc);
            scw = PartialBitBoard512.AndNot(ml1d1, scw);
            // Calculate offset #2 (2, 0) as mr2
            var mr2 = m << 2;
            // Calculate offset #2 (2, -1) as mr2d1
            var mr2d1 = md1 << 2;
            result = rtcc0 | rtcw0;
            rtcw1 = rtcw1 << 1;
            // Calculate y = 1 offset #3 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #2 (2, 0)(mr2)
            // Test Clockwise rotation from Right with offset #2 (2, -1)(mr2d1)
            rtcw1 = PartialBitBoard512.ShiftDownOneLine(rtcw1, filled);
            rtcc0 = scc & mr2;
            rtcw0 = scw & mr2d1;
            scc = PartialBitBoard512.AndNot(mr2, scc);
            scw = PartialBitBoard512.AndNot(mr2d1, scw);
            // Calculate offset #3 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            rtcw0 = rtcw0 >> 2;
            // Calculate y = 2 offset #4 as mu2
            var mu2 = PartialBitBoard512.ShiftDownTwoLines(mobility, filled);
            // Calculate y = -2 offset #4 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            rtcc0 = rtcc0 >> 2;
            // Test CounterClockwise rotation from Left with offset #3 (-1, -1)(ml1d1)
            // Test Clockwise rotation from Right with offset #3 (-1, 1)(ml1u1)
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcw0 = PartialBitBoard512.ShiftDownOneLine(rtcw0, filled);
            rtcw1 = scw & ml1u1;
            rtcc1 = scc & ml1d1;
            scw = PartialBitBoard512.AndNot(ml1u1, scw);
            scc = PartialBitBoard512.AndNot(ml1d1, scc);
            // Calculate offset #4 (2, 2) as mr2u2
            var mr2u2 = mu2 << 2;
            // Calculate offset #4 (2, -2) as mr2d2
            var mr2d2 = md2 << 2;
            rtcw1 = rtcw1 << 1;
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Left with offset #4 (2, 2)(mr2u2)
            // Test Clockwise rotation from Right with offset #4 (2, -2)(mr2d2)
            result = PartialBitBoard512.OrAll(result, rtcc0, rtcw0);
            rtcw1 = PartialBitBoard512.ShiftUpOneLine(rtcw1, filled);
            rtcc0 = scc & mr2u2;
            rtcw0 = scw & mr2d2;
            rtcc1 = PartialBitBoard512.ShiftDownOneLine(rtcc1, filled);
            scc = PartialBitBoard512.AndNot(mr2u2, scc);
            scw = PartialBitBoard512.AndNot(mr2d2, scw);
            rtcw0 = rtcw0 >> 2;
            rtcc0 = rtcc0 >> 2;
            result = PartialBitBoard512.OrAll(result, rtcc1, rtcw1);
            rtcc0 = PartialBitBoard512.ShiftUpTwoLines(rtcc0, filled);
            rtcw0 = PartialBitBoard512.ShiftDownTwoLines(rtcw0, filled);
            result = PartialBitBoard512.OrAll(result, rtcc0, rtcw0);
            return result;
        }

        [SkipLocalsInit]
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static TBitBoard RotateToLeft(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            if (leftMobility is PartialBitBoard512 zmm0 && downReached is PartialBitBoard512 zmm1 && upReached is PartialBitBoard512 zmm2)
            {
                if (RotateToLeftInternal(zmm0, zmm1, zmm2) is TBitBoard t) return t;
                return default;
            }
            return RotateToLeftInternal(leftMobility, downReached, upReached);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static TBitBoard RotateToLeftInternal(TBitBoard leftMobility, TBitBoard downReached, TBitBoard upReached)
        {
            // Rotation from Up and Down to Left 
            TBitBoard scc = upReached;
            TBitBoard scw = downReached;
            TBitBoard mobility = leftMobility;
            TBitBoard result;
            TBitBoard filled = TBitBoard.Zero;
            TBitBoard rtcc0;
            TBitBoard rtcc1;
            TBitBoard rtcw0;
            TBitBoard rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = -1 offset #0 as md1
            var md1 = TBitBoard.ShiftUpOneLine(mobility, filled);
            // Calculate offset #0 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Offset #0 (0, -1)(md1) is already available.
            // Test Clockwise rotation from Down with offset #0 (-1, 0)(ml1)
            // Test CounterClockwise rotation from Up with offset #0 (0, -1)(md1)
            rtcw0 = scw & ml1;
            rtcc0 = scc & md1;
            scw = TBitBoard.AndNot(ml1, scw);
            scc = TBitBoard.AndNot(md1, scc);
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcw0 = rtcw0 << 1;
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            // Test CounterClockwise rotation from Up with offset #1 (-1, -1)(ml1d1)
            rtcw1 = scw & mr1;
            rtcc1 = scc & ml1d1;
            scw = TBitBoard.AndNot(mr1, scw);
            scc = TBitBoard.AndNot(ml1d1, scc);
            // Calculate offset #2 (-2, 0) as ml2
            var ml2 = m >> 2;
            // Calculate offset #2 (2, -1) as mr2d1
            var mr2d1 = md1 << 2;
            result = rtcw0 | rtcc0;
            rtcc1 = rtcc1 << 1;
            // Calculate y = 1 offset #3 as mu1
            var mu1 = TBitBoard.ShiftDownOneLine(mobility, filled);
            rtcw1 = rtcw1 >> 1;
            // Test Clockwise rotation from Down with offset #2 (-2, 0)(ml2)
            // Test CounterClockwise rotation from Up with offset #2 (2, -1)(mr2d1)
            rtcc1 = TBitBoard.ShiftDownOneLine(rtcc1, filled);
            rtcw0 = scw & ml2;
            rtcc0 = scc & mr2d1;
            scw = TBitBoard.AndNot(ml2, scw);
            scc = TBitBoard.AndNot(mr2d1, scc);
            // Calculate offset #3 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Calculate offset #3 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcc0 = rtcc0 >> 2;
            // Calculate y = -2 offset #4 as md2
            var md2 = TBitBoard.ShiftUpTwoLines(mobility, filled);
            rtcw0 = rtcw0 << 2;
            // Test CounterClockwise rotation from Up with offset #3 (-1, 1)(ml1u1)
            // Test Clockwise rotation from Down with offset #3 (1, 1)(mr1u1)
            result = TBitBoard.OrAll(result, rtcw1, rtcc1);
            rtcc0 = TBitBoard.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & ml1u1;
            rtcw1 = scw & mr1u1;
            scc = TBitBoard.AndNot(ml1u1, scc);
            scw = TBitBoard.AndNot(mr1u1, scw);
            // Calculate offset #4 (2, -2) as mr2d2
            var mr2d2 = md2 << 2;
            // Calculate offset #4 (-2, -2) as ml2d2
            var ml2d2 = md2 >> 2;
            rtcw1 = rtcw1 >> 1;
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Up with offset #4 (2, -2)(mr2d2)
            // Test Clockwise rotation from Down with offset #4 (-2, -2)(ml2d2)
            rtcc1 |= rtcw1;
            result = TBitBoard.OrAll(result, rtcw0, rtcc0);
            rtcc1 = TBitBoard.ShiftUpOneLine(rtcc1, filled);
            rtcc0 = scc & mr2d2;
            rtcw0 = scw & ml2d2;
            result |= rtcc1;
            scc = TBitBoard.AndNot(mr2d2, scc);
            scw = TBitBoard.AndNot(ml2d2, scw);
            rtcw0 = rtcw0 << 2;
            rtcc0 = rtcc0 >> 2;
            rtcc0 |= rtcw0;
            rtcc0 = TBitBoard.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        private static PartialBitBoard512 RotateToLeftInternal(PartialBitBoard512 leftMobility, PartialBitBoard512 downReached, PartialBitBoard512 upReached)
        {
            // Rotation from Up and Down to Left 
            Vector512<ushort> scc = upReached;
            Vector512<ushort> scw = downReached;
            Vector512<ushort> mobility = leftMobility;
            Vector512<ushort> result;
            Vector512<ushort> filled = Vector256<ushort>.Zero.ToVector512Unsafe();
            Vector512<ushort> rtcc0;
            Vector512<ushort> rtcc1;
            Vector512<ushort> rtcw0;
            Vector512<ushort> rtcw1;
            // Calculate y = 0 offset #0 as m
            var m = mobility;
            // Calculate y = -1 offset #0 as md1
            var md1 = PartialBitBoard512.ShiftUpOneLine(mobility, filled);
            // Calculate offset #0 (-1, 0) as ml1
            var ml1 = m >> 1;
            // Offset #0 (0, -1)(md1) is already available.
            // Test Clockwise rotation from Down with offset #0 (-1, 0)(ml1)
            // Test CounterClockwise rotation from Up with offset #0 (0, -1)(md1)
            rtcw0 = scw & ml1;
            rtcc0 = scc & md1;
            scw = PartialBitBoard512.AndNot(ml1, scw);
            scc = PartialBitBoard512.AndNot(md1, scc);
            // Calculate offset #1 (1, 0) as mr1
            var mr1 = m << 1;
            // Calculate offset #1 (-1, -1) as ml1d1
            var ml1d1 = md1 >> 1;
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcw0 = rtcw0 << 1;
            // Test Clockwise rotation from Down with offset #1 (1, 0)(mr1)
            // Test CounterClockwise rotation from Up with offset #1 (-1, -1)(ml1d1)
            rtcw1 = scw & mr1;
            rtcc1 = scc & ml1d1;
            scw = PartialBitBoard512.AndNot(mr1, scw);
            scc = PartialBitBoard512.AndNot(ml1d1, scc);
            // Calculate offset #2 (-2, 0) as ml2
            var ml2 = m >> 2;
            // Calculate offset #2 (2, -1) as mr2d1
            var mr2d1 = md1 << 2;
            result = rtcw0 | rtcc0;
            rtcc1 = rtcc1 << 1;
            // Calculate y = 1 offset #3 as mu1
            var mu1 = PartialBitBoard512.ShiftDownOneLine(mobility, filled);
            rtcw1 = rtcw1 >> 1;
            // Test Clockwise rotation from Down with offset #2 (-2, 0)(ml2)
            // Test CounterClockwise rotation from Up with offset #2 (2, -1)(mr2d1)
            rtcc1 = PartialBitBoard512.ShiftDownOneLine(rtcc1, filled);
            rtcw0 = scw & ml2;
            rtcc0 = scc & mr2d1;
            scw = PartialBitBoard512.AndNot(ml2, scw);
            scc = PartialBitBoard512.AndNot(mr2d1, scc);
            // Calculate offset #3 (-1, 1) as ml1u1
            var ml1u1 = mu1 >> 1;
            // Calculate offset #3 (1, 1) as mr1u1
            var mr1u1 = mu1 << 1;
            rtcc0 = rtcc0 >> 2;
            // Calculate y = -2 offset #4 as md2
            var md2 = PartialBitBoard512.ShiftUpTwoLines(mobility, filled);
            rtcw0 = rtcw0 << 2;
            // Test CounterClockwise rotation from Up with offset #3 (-1, 1)(ml1u1)
            // Test Clockwise rotation from Down with offset #3 (1, 1)(mr1u1)
            result = PartialBitBoard512.OrAll(result, rtcw1, rtcc1);
            rtcc0 = PartialBitBoard512.ShiftDownOneLine(rtcc0, filled);
            rtcc1 = scc & ml1u1;
            rtcw1 = scw & mr1u1;
            scc = PartialBitBoard512.AndNot(ml1u1, scc);
            scw = PartialBitBoard512.AndNot(mr1u1, scw);
            // Calculate offset #4 (2, -2) as mr2d2
            var mr2d2 = md2 << 2;
            // Calculate offset #4 (-2, -2) as ml2d2
            var ml2d2 = md2 >> 2;
            rtcw1 = rtcw1 >> 1;
            rtcc1 = rtcc1 << 1;
            // Test CounterClockwise rotation from Up with offset #4 (2, -2)(mr2d2)
            // Test Clockwise rotation from Down with offset #4 (-2, -2)(ml2d2)
            rtcc1 |= rtcw1;
            result = PartialBitBoard512.OrAll(result, rtcw0, rtcc0);
            rtcc1 = PartialBitBoard512.ShiftUpOneLine(rtcc1, filled);
            rtcc0 = scc & mr2d2;
            rtcw0 = scw & ml2d2;
            result |= rtcc1;
            scc = PartialBitBoard512.AndNot(mr2d2, scc);
            scw = PartialBitBoard512.AndNot(ml2d2, scw);
            rtcw0 = rtcw0 << 2;
            rtcc0 = rtcc0 >> 2;
            rtcc0 |= rtcw0;
            rtcc0 = PartialBitBoard512.ShiftDownTwoLines(rtcc0, filled);
            result |= rtcc0;
            return result;
        }

        #endregion RotateTo
    }


}

