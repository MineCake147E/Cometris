<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

var Orientations = new (string name, uint value)[]{ ("Up", 0), ("Right", 1), ("Down", 2), ("Left", 3)};
var Rotations = new (string name, int offset)[]{ ("Clockwise", 1), ("CounterClockwise", -1)};
static uint GetOrientationAfterRotation(uint value, int offset) => (uint)(value + (uint)offset) & 3;
#>
// <auto-generated />
// Environment.Version: <#=Environment.Version#>
using System;
using System.Numerics;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Cometris.Boards;

namespace Cometris.Movements
{
    public partial interface IRotatabilityLocator<TSelf, TBitBoard>
    {
<#
    foreach(var o in Orientations){
        foreach(var r in Rotations){#>
        
        static abstract TBitBoard Rotate<#=r.name#>From<#=o.name#>(TBitBoard <#=Orientations[GetOrientationAfterRotation(o.value, r.offset)].name.ToLower()#>Mobility, TBitBoard reached);
<#      }
    }
    foreach(var o in Orientations){#>

        static virtual TBitBoard RotateTo<#=o.name#>(TBitBoard <#=o.name.ToLower()#>Mobility, TBitBoard <#=Orientations[GetOrientationAfterRotation(o.value, -1)].name.ToLower()#>Reached, TBitBoard <#=Orientations[GetOrientationAfterRotation(o.value, 1)].name.ToLower()#>Reached)
            => <#=string.Join(" | ", Rotations.Select(r => (r, oa: Orientations[GetOrientationAfterRotation(o.value, -r.offset)])).Select(a => $"TSelf.Rotate{a.r.name}From{a.oa.name}({o.name.ToLower()}Mobility, {a.oa.name.ToLower()}Reached)"))#>;
<#
    }#>
    }
}
