// <auto-generated />
// Environment.Version: 9.0.0
using System;
using System.Numerics;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using Cometris.Boards;
using Cometris.Utils;
using Cometris.Movements;
using MikoMino;

namespace Cometris.Tests.Movements
{
    public partial class PieceRotatabilityLocatorTests<TBitBoard>
    {
        #region JLSZ
        #region RotateFrom
        private static IEnumerable<Point> PieceJLSZClockwiseRotationFromUpOffsets()
            => Offsets[(Angle)0].Zip(Offsets[(Angle)1], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZClockwiseRotationFromUpTestCaseSource()
            => PieceJLSZClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZClockwiseRotationFromUpTestCaseSource))]
        public void PieceJLSZRotateClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZCounterClockwiseRotationFromUpOffsets()
            => Offsets[(Angle)0].Zip(Offsets[(Angle)3], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZCounterClockwiseRotationFromUpTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZCounterClockwiseRotationFromUpTestCaseSource))]
        public void PieceJLSZRotateCounterClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZClockwiseRotationFromRightOffsets()
            => Offsets[(Angle)1].Zip(Offsets[(Angle)2], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZClockwiseRotationFromRightTestCaseSource()
            => PieceJLSZClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZClockwiseRotationFromRightTestCaseSource))]
        public void PieceJLSZRotateClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZCounterClockwiseRotationFromRightOffsets()
            => Offsets[(Angle)1].Zip(Offsets[(Angle)0], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZCounterClockwiseRotationFromRightTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZCounterClockwiseRotationFromRightTestCaseSource))]
        public void PieceJLSZRotateCounterClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZClockwiseRotationFromDownOffsets()
            => Offsets[(Angle)2].Zip(Offsets[(Angle)3], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZClockwiseRotationFromDownTestCaseSource()
            => PieceJLSZClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZClockwiseRotationFromDownTestCaseSource))]
        public void PieceJLSZRotateClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZCounterClockwiseRotationFromDownOffsets()
            => Offsets[(Angle)2].Zip(Offsets[(Angle)1], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZCounterClockwiseRotationFromDownTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZCounterClockwiseRotationFromDownTestCaseSource))]
        public void PieceJLSZRotateCounterClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZClockwiseRotationFromLeftOffsets()
            => Offsets[(Angle)3].Zip(Offsets[(Angle)0], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZClockwiseRotationFromLeftTestCaseSource()
            => PieceJLSZClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZClockwiseRotationFromLeftTestCaseSource))]
        public void PieceJLSZRotateClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceJLSZCounterClockwiseRotationFromLeftOffsets()
            => Offsets[(Angle)3].Zip(Offsets[(Angle)2], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceJLSZCounterClockwiseRotationFromLeftTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceJLSZCounterClockwiseRotationFromLeftTestCaseSource))]
        public void PieceJLSZRotateCounterClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        #endregion RotateFrom
        #region RotateTo
        private static IEnumerable<TestCaseData> PieceJLSZRotationToUpTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromRightOffsets().SelectMany(cc => PieceJLSZClockwiseRotationFromLeftOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceJLSZRotationToUpTestCaseSource))]
        public void PieceJLSZRotateToUpRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateToUp(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceJLSZRotationToRightTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromDownOffsets().SelectMany(cc => PieceJLSZClockwiseRotationFromUpOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceJLSZRotationToRightTestCaseSource))]
        public void PieceJLSZRotateToRightRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateToRight(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceJLSZRotationToDownTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromLeftOffsets().SelectMany(cc => PieceJLSZClockwiseRotationFromRightOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceJLSZRotationToDownTestCaseSource))]
        public void PieceJLSZRotateToDownRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateToDown(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceJLSZRotationToLeftTestCaseSource()
            => PieceJLSZCounterClockwiseRotationFromUpOffsets().SelectMany(cc => PieceJLSZClockwiseRotationFromDownOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceJLSZRotationToLeftTestCaseSource))]
        public void PieceJLSZRotateToLeftRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceJLSZRotatabilityLocator<TBitBoard>.RotateToLeft(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        #endregion RotateTo
        #endregion JLSZ
        #region T
        #region RotateFrom
        private static IEnumerable<Point> PieceTClockwiseRotationFromUpOffsets()
            => Offsets[(Angle)0].Zip(Offsets[(Angle)1], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)0], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTClockwiseRotationFromUpTestCaseSource()
            => PieceTClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTClockwiseRotationFromUpTestCaseSource))]
        public void PieceTRotateClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTCounterClockwiseRotationFromUpOffsets()
            => Offsets[(Angle)0].Zip(Offsets[(Angle)3], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)0], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTCounterClockwiseRotationFromUpTestCaseSource()
            => PieceTCounterClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTCounterClockwiseRotationFromUpTestCaseSource))]
        public void PieceTRotateCounterClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTClockwiseRotationFromRightOffsets()
            => Offsets[(Angle)1].Zip(Offsets[(Angle)2], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)1], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTClockwiseRotationFromRightTestCaseSource()
            => PieceTClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTClockwiseRotationFromRightTestCaseSource))]
        public void PieceTRotateClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTCounterClockwiseRotationFromRightOffsets()
            => Offsets[(Angle)1].Zip(Offsets[(Angle)0], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)1], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTCounterClockwiseRotationFromRightTestCaseSource()
            => PieceTCounterClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTCounterClockwiseRotationFromRightTestCaseSource))]
        public void PieceTRotateCounterClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTClockwiseRotationFromDownOffsets()
            => Offsets[(Angle)2].Zip(Offsets[(Angle)3], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)2], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTClockwiseRotationFromDownTestCaseSource()
            => PieceTClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTClockwiseRotationFromDownTestCaseSource))]
        public void PieceTRotateClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTCounterClockwiseRotationFromDownOffsets()
            => Offsets[(Angle)2].Zip(Offsets[(Angle)1], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)2], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTCounterClockwiseRotationFromDownTestCaseSource()
            => PieceTCounterClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTCounterClockwiseRotationFromDownTestCaseSource))]
        public void PieceTRotateCounterClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTClockwiseRotationFromLeftOffsets()
            => Offsets[(Angle)3].Zip(Offsets[(Angle)0], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)3], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTClockwiseRotationFromLeftTestCaseSource()
            => PieceTClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTClockwiseRotationFromLeftTestCaseSource))]
        public void PieceTRotateClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceTCounterClockwiseRotationFromLeftOffsets()
            => Offsets[(Angle)3].Zip(Offsets[(Angle)2], (b, a) => b - a).Zip(IgnoreForTPiece[(Angle)3], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o);

        private static IEnumerable<TestCaseData> PieceTCounterClockwiseRotationFromLeftTestCaseSource()
            => PieceTCounterClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceTCounterClockwiseRotationFromLeftTestCaseSource))]
        public void PieceTRotateCounterClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        #endregion RotateFrom
        #region RotateTo
        private static IEnumerable<TestCaseData> PieceTRotationToUpTestCaseSource()
            => PieceTCounterClockwiseRotationFromRightOffsets().SelectMany(cc => PieceTClockwiseRotationFromLeftOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceTRotationToUpTestCaseSource))]
        public void PieceTRotateToUpRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateToUp(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceTRotationToRightTestCaseSource()
            => PieceTCounterClockwiseRotationFromDownOffsets().SelectMany(cc => PieceTClockwiseRotationFromUpOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceTRotationToRightTestCaseSource))]
        public void PieceTRotateToRightRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateToRight(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceTRotationToDownTestCaseSource()
            => PieceTCounterClockwiseRotationFromLeftOffsets().SelectMany(cc => PieceTClockwiseRotationFromRightOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceTRotationToDownTestCaseSource))]
        public void PieceTRotateToDownRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateToDown(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceTRotationToLeftTestCaseSource()
            => PieceTCounterClockwiseRotationFromUpOffsets().SelectMany(cc => PieceTClockwiseRotationFromDownOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceTRotationToLeftTestCaseSource))]
        public void PieceTRotateToLeftRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceTRotatabilityLocator<TBitBoard>.RotateToLeft(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        #endregion RotateTo
        #endregion T
        #region I
        #region RotateFrom
        private static IEnumerable<Point> PieceIClockwiseRotationFromUpOffsets()
            => OffsetsIPiece[(Angle)0].Zip(OffsetsIPiece[(Angle)1], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceIClockwiseRotationFromUpTestCaseSource()
            => PieceIClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceIClockwiseRotationFromUpTestCaseSource))]
        public void PieceIRotateClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceICounterClockwiseRotationFromUpOffsets()
            => OffsetsIPiece[(Angle)0].Zip(OffsetsIPiece[(Angle)3], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceICounterClockwiseRotationFromUpTestCaseSource()
            => PieceICounterClockwiseRotationFromUpOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceICounterClockwiseRotationFromUpTestCaseSource))]
        public void PieceIRotateCounterClockwiseFromUpRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromUp(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceIClockwiseRotationFromRightOffsets()
            => OffsetsIPiece[(Angle)1].Zip(OffsetsIPiece[(Angle)2], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceIClockwiseRotationFromRightTestCaseSource()
            => PieceIClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceIClockwiseRotationFromRightTestCaseSource))]
        public void PieceIRotateClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceICounterClockwiseRotationFromRightOffsets()
            => OffsetsIPiece[(Angle)1].Zip(OffsetsIPiece[(Angle)0], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceICounterClockwiseRotationFromRightTestCaseSource()
            => PieceICounterClockwiseRotationFromRightOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceICounterClockwiseRotationFromRightTestCaseSource))]
        public void PieceIRotateCounterClockwiseFromRightRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromRight(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceIClockwiseRotationFromDownOffsets()
            => OffsetsIPiece[(Angle)2].Zip(OffsetsIPiece[(Angle)3], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceIClockwiseRotationFromDownTestCaseSource()
            => PieceIClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceIClockwiseRotationFromDownTestCaseSource))]
        public void PieceIRotateClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceICounterClockwiseRotationFromDownOffsets()
            => OffsetsIPiece[(Angle)2].Zip(OffsetsIPiece[(Angle)1], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceICounterClockwiseRotationFromDownTestCaseSource()
            => PieceICounterClockwiseRotationFromDownOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceICounterClockwiseRotationFromDownTestCaseSource))]
        public void PieceIRotateCounterClockwiseFromDownRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromDown(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceIClockwiseRotationFromLeftOffsets()
            => OffsetsIPiece[(Angle)3].Zip(OffsetsIPiece[(Angle)0], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceIClockwiseRotationFromLeftTestCaseSource()
            => PieceIClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceIClockwiseRotationFromLeftTestCaseSource))]
        public void PieceIRotateClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        private static IEnumerable<Point> PieceICounterClockwiseRotationFromLeftOffsets()
            => OffsetsIPiece[(Angle)3].Zip(OffsetsIPiece[(Angle)2], (b, a) => b - a);

        private static IEnumerable<TestCaseData> PieceICounterClockwiseRotationFromLeftTestCaseSource()
            => PieceICounterClockwiseRotationFromLeftOffsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(PieceICounterClockwiseRotationFromLeftTestCaseSource))]
        public void PieceIRotateCounterClockwiseFromLeftRotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateCounterClockwiseFromLeft(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

        #endregion RotateFrom
        #region RotateTo
        private static IEnumerable<TestCaseData> PieceIRotationToUpTestCaseSource()
            => PieceICounterClockwiseRotationFromRightOffsets().SelectMany(cc => PieceIClockwiseRotationFromLeftOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceIRotationToUpTestCaseSource))]
        public void PieceIRotateToUpRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateToUp(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceIRotationToRightTestCaseSource()
            => PieceICounterClockwiseRotationFromDownOffsets().SelectMany(cc => PieceIClockwiseRotationFromUpOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceIRotationToRightTestCaseSource))]
        public void PieceIRotateToRightRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateToRight(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceIRotationToDownTestCaseSource()
            => PieceICounterClockwiseRotationFromLeftOffsets().SelectMany(cc => PieceIClockwiseRotationFromRightOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceIRotationToDownTestCaseSource))]
        public void PieceIRotateToDownRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateToDown(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        private static IEnumerable<TestCaseData> PieceIRotationToLeftTestCaseSource()
            => PieceICounterClockwiseRotationFromUpOffsets().SelectMany(cc => PieceIClockwiseRotationFromDownOffsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(PieceIRotationToLeftTestCaseSource))]
        public void PieceIRotateToLeftRotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = PieceIRotatabilityLocator<TBitBoard>.RotateToLeft(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
        #endregion RotateTo
        #endregion I
    }
}