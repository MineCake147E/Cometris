<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ parameter name="Configuration" type="string" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
#nullable enable
var Orientations = new (string name, uint value)[]{ ("Up", 0), ("Right", 1), ("Down", 2), ("Left", 3)};
var Rotations = new (string name, int offset)[]{ ("Clockwise", 1), ("CounterClockwise", -1)};
var Pieces = new (string name, string offsetsName, bool isTPiece)[]{("JLSZ", "Offsets", false), ("T", "Offsets", true), ("I", "OffsetsIPiece", false)};
static uint GetOrientationAfterRotation(uint value, int offset) => (uint)(value + (uint)offset) & 3;
#>
// <auto-generated />
// Environment.Version: <#=Environment.Version#>
using System;
using System.Numerics;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using Cometris.Boards;
using Cometris.Utils;
using Cometris.Movements;

namespace Cometris.Tests.Movements
{
    public partial class PieceRotatabilityLocatorTests<TBitBoard>
    {
<#
    foreach (var p in Pieces)
    {
#>
        #region <#=p.name#>
        #region RotateFrom
<#
        foreach(var o in Orientations)
        {
            foreach(var r in Rotations)
            {
                var oAfter = Orientations[GetOrientationAfterRotation(o.value, r.offset)];
#>
        private static IEnumerable<Point> Piece<#=p.name#><#=r.name#>RotationFrom<#=o.name#>Offsets()
            => <#=p.offsetsName#>[(Angle)<#=o.value#>].Zip(<#=p.offsetsName#>[(Angle)<#=oAfter.value#>], (b, a) => b - a)<#
                if (p.isTPiece)
                {
#>.Zip(IgnoreForTPiece[(Angle)<#=o.value#>], (o, i) => (o, i)).Where(a => !a.i).Select(a => a.o)<#
                }
#>
;

        private static IEnumerable<TestCaseData> Piece<#=p.name#><#=r.name#>RotationFrom<#=o.name#>TestCaseSource()
            => Piece<#=p.name#><#=r.name#>RotationFrom<#=o.name#>Offsets().Select(a => new TestCaseData(a));

        [TestCaseSource(nameof(Piece<#=p.name#><#=r.name#>RotationFrom<#=o.name#>TestCaseSource))]
        public void Piece<#=p.name#>Rotate<#=r.name#>From<#=o.name#>RotatesCorrectly(Point offset)
        {
            var reached = TBitBoard.CreateSingleBlock(7, 15);
            var pos = offset + new Point(7, 15);
            var mobility = TBitBoard.CreateSingleBlock(pos.X, pos.Y);
            var result = Piece<#=p.name#>RotatabilityLocator<TBitBoard>.Rotate<#=r.name#>From<#=o.name#>(mobility, reached);
            Assert.That(result, Is.EqualTo(mobility));
        }

<#          }
        }
#>
        #endregion RotateFrom
        #region RotateTo
<#
        foreach(var o in Orientations)
        {
            var occ = Orientations[GetOrientationAfterRotation(o.value, 1)];
            var ocw = Orientations[GetOrientationAfterRotation(o.value, -1)];
#>
        private static IEnumerable<TestCaseData> Piece<#=p.name#>RotationTo<#=o.name#>TestCaseSource()
            => Piece<#=p.name#>CounterClockwiseRotationFrom<#=occ.name#>Offsets().SelectMany(cc => Piece<#=p.name#>ClockwiseRotationFrom<#=ocw.name#>Offsets().Select(cw => new TestCaseData(cc, cw)));
        
        [TestCaseSource(nameof(Piece<#=p.name#>RotationTo<#=o.name#>TestCaseSource))]
        public void Piece<#=p.name#>RotateTo<#=o.name#>RotatesCorrectly(Point offsetCounterClockwise, Point offsetClockwise)
        {
            var pcc = new Point(7, 7) - offsetCounterClockwise;
            var pcw = new Point(8, 23) - offsetClockwise;
            var ccReached = TBitBoard.CreateSingleBlock(pcc.X, pcc.Y);
            var cwReached = TBitBoard.CreateSingleBlock(pcw.X, pcw.Y);
            var mobility = TBitBoard.CreateSingleBlock(7, 7) | TBitBoard.CreateSingleBlock(8, 23);
            var result = Piece<#=p.name#>RotatabilityLocator<TBitBoard>.RotateTo<#=o.name#>(mobility, cwReached, ccReached);
            Assert.That(result, Is.EqualTo(mobility));
        }
<#
        }#>
        #endregion RotateTo
        #endregion <#=p.name#>
<#
    }
#>
    }
}